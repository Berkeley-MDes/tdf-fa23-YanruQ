# PHYSICAL COMPUTING - WEEK 5 #

**PROJECT NAME:** Loud Rabbit  
**GROUP MEMBERS:** Yoojin Leem, Stephanie He, Yanru Qian  
**OVERVIEW:** Moving cahracters with two different modes. When people approched the object in its "SHY" mode, it runs away from people. When it's in "FRIENDLY" mode  . 
**CHALLENGES:**  
- Combining 
- 

Following the simple servo motors test from last week, I went deeper into motor movement and how to control the direction of spinning.  
### PROCEDURE 1 ###
⬇️ Sucessfully operating two servo motors at the same time. ⬇️ Even though we ended up deciding not to use servo motors, I learned a lot about the machanism of motors and how it recieves signal which then applied the knowledge to the later exploration with DC motors.


https://github.com/Berkeley-MDes/tdf-fa23-YanruQ/assets/142960866/0122f5f2-24a7-44a6-82d5-45ba94c6a9e3

### PROCEDURE 2 ###
⬇️ Activating **ultrasonic sensor** for incoporating distances between the subject and the object into this interactive process. ⬇️  
Before choosing the ultrasonic sensor, we also tested a PIR sensor. We decided to settle on the ultrasonic sensor because it provides accurate distance information (even though it's from a linear direction). We can manipulate the movement based on the measured distance rather than a simple 1/0 signal.

https://github.com/Berkeley-MDes/tdf-fa23-YanruQ/assets/142960866/8ed9a14a-f7eb-4122-ad83-18d453223a3c


### PROCEDURE 3 ###
⬇️ Setting up the structure for the moving object ⬇️  
We switched from servo motors to DC motors because the power of servo motor is not strong enough to support the wheel movement.
<img height=360 src="https://github.com/Berkeley-MDes/tdf-fa23-YanruQ/assets/142960866/bb17d55e-8b71-48eb-b370-63d20042bf60">
<img height=360 src="https://github.com/Berkeley-MDes/tdf-fa23-YanruQ/assets/142960866/93b1364e-bdd9-4cf9-8607-cd3421ea9546">  
To change the spinning direction, we need motor driver. Jeff offered us an [DC motor FeatherWing Board](https://www.adafruit.com/product/2927), and taught us how to soldering. It took us half a day to enable the moving functions, connecting extra power source to drive the motor running. We could also change the speed but we found out that there's an unpleasing sound generated when the speed are really slow. 


https://github.com/Berkeley-MDes/tdf-fa23-YanruQ/assets/142960866/924137dd-886f-4ad1-8517-cb324c1a146b

### PROCEDURE 4 ###
⬇️ Code for the moving objects ⬇️  
Essentially, we combined the codes from the previous exercise with this one. It took me a long time to understand the function of [interrupts](https://docs.particle.io/reference/device-os/api/interrupts/interrupts/ ) (I included the link for my own reference), but basically, the device won't send messages multiple times when it's within the range set for the "window." In Thursday's session, we also worked on the communication between two photons. After creating a shared project between two accounts, photons were able to print messages in the monitor. This part of the code is only used to activate different moving modes for the objects. The settings will change based on the input given by the other photon. Enabling cloud communication is definitely a tricky part; we need to clearly figure out what kinds of information need to be transported in between.
```Ruby
int setting;
#include "Adafruit_PWMServoDriver.h"
#include "Adafruit-MotorShield-V2.h"
#define TRIG D2
#define ECHO D4
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_DCMotor *myMotor = AFMS.getMotor(1);
Adafruit_DCMotor *myMotor2 = AFMS.getMotor(4);
void setup() {
    pinMode(D7, OUTPUT);
    Particle.subscribe("toggle-led", friendly);  // Change MY_DEVICES as needed
    Particle.subscribe("other-led", shy);  // Change MY_DEVICES as needed
    //og code
    Serial.begin(9600);
    pinMode(TRIG, OUTPUT);
    pinMode(ECHO, INPUT);
    AFMS.begin();
    myMotor->setSpeed(255);
    myMotor2->setSpeed(255);
    myMotor->run(FORWARD);
    myMotor2->run(FORWARD);
}
void loop() {
    Particle.publish("hi", "i am alive!", PRIVATE);
    if(setting == 0) {
        //friendly code
        Particle.publish("hi", "friendly", PRIVATE);
        long duration, distance;
        digitalWrite(TRIG, LOW);
        delayMicroseconds(2);
        digitalWrite(TRIG, HIGH);
        delayMicroseconds(10);
        digitalWrite(TRIG, LOW);
        duration = pulseIn(ECHO, HIGH);
        distance = (duration / 2) * 0.0344;
        // Print the distance to the Serial Monitor
        Serial.print("Distance: ");
        Serial.print(distance);
        Serial.println(" CM");
        // Stop motors if the distance is less than 10cm
        if (distance < 10) {
            myMotor->run(RELEASE);
            myMotor2->run(RELEASE);
        } else {
            myMotor->run(FORWARD);
            myMotor2->run(FORWARD);
        }
        delay(500);
        }
    else if (setting == 1) {
        //shy code
        Particle.publish("hi", "shy", PRIVATE);
        long duration, distance;
        digitalWrite(TRIG, LOW);
        delayMicroseconds(2);
        digitalWrite(TRIG, HIGH);
        delayMicroseconds(10);
        digitalWrite(TRIG, LOW);
        duration = pulseIn(ECHO, HIGH);
        distance = (duration / 2) * 0.0344;
        // Print the distance to the Serial Monitor
        Serial.print("Distance: ");
        Serial.print(distance);
        Serial.println(" CM");
        // Stop motors if the distance is more than 10cm
        if (distance > 10) {
            myMotor->run(RELEASE);
            myMotor2->run(RELEASE);
        } else {
            myMotor->run(BACKWARD);
            myMotor2->run(BACKWARD);
        }
        delay(500);
        }
}
```
### REFLECTION & SPECULATION ###
